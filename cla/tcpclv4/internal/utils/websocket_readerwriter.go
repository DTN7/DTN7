// SPDX-FileCopyrightText: 2020 Alvar Penning
//
// SPDX-License-Identifier: GPL-3.0-or-later

package utils

import (
	"fmt"
	"io"

	"github.com/gorilla/websocket"
)

// WebSocketReadWriteFlushCloser is a combined io.Reader, io.Closer, and WriteFlusher for a *websocket.Conn.
//
// The so called Reader and Writer generated by NextReader resp. NextWriter from websocket.Conn are only valid for
// one WebSocket message. Those should be used in a fire-and-forget way, requiring to create a new one after each call.
// Furthermore, their Writer has some internal buffering.
//
// This type is a wrapper around a *websocket.Conn to be used as typical io.Reader/io.Writer.
type WebSocketReadWriteFlushCloser struct {
	conn        *websocket.Conn
	messageType int

	wc io.WriteCloser
}

// NewWebSocketReadWriteFlushCloser for a WebSocket connection.
func NewWebSocketReadWriteFlushCloser(conn *websocket.Conn) *WebSocketReadWriteFlushCloser {
	return &WebSocketReadWriteFlushCloser{
		conn:        conn,
		messageType: websocket.BinaryMessage,
	}
}

// Read the next message.
func (rw *WebSocketReadWriteFlushCloser) Read(p []byte) (n int, err error) {
	if mt, r, rErr := rw.conn.NextReader(); rErr != nil {
		return 0, rErr
	} else if mt != rw.messageType {
		return 0, fmt.Errorf("expected message type %d instead of %d", rw.messageType, mt)
	} else {
		return r.Read(p)
	}
}

// Write the next message. A call to Flush is required for the data to be written to the underlying stream.
func (rw *WebSocketReadWriteFlushCloser) Write(p []byte) (n int, err error) {
	if rw.wc == nil {
		if rw.wc, err = rw.conn.NextWriter(rw.messageType); err != nil {
			return
		}
	}

	return rw.wc.Write(p)
}

// Flush the data to the underlying stream.
func (rw *WebSocketReadWriteFlushCloser) Flush() (err error) {
	if rw.wc != nil {
		err = rw.wc.Close()
		rw.wc = nil
	}

	return
}

// Close this WebSocketReadWriteFlushCloser and the underlying WebSocket connection.
func (rw *WebSocketReadWriteFlushCloser) Close() error {
	return rw.conn.Close()
}
