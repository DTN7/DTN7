package bundle

import (
	"bytes"
	"fmt"
	"math/rand"
	"reflect"
	"testing"

	"github.com/dtn7/cboring"
)

func TestBundleApplyCRC(t *testing.T) {
	var epPrim, _ = NewEndpointID("dtn:foo/bar")
	var creationTs = NewCreationTimestamp(4200, 23)

	var primary = NewPrimaryBlock(
		StatusRequestDelivery,
		epPrim, epPrim, creationTs, 42000)

	var epPrev, _ = NewEndpointID("ipn:23.42")
	var prevNode = NewCanonicalBlock(2, 0, NewPreviousNodeBlock(epPrev))

	var payload = NewCanonicalBlock(1, DeleteBundle, NewPayloadBlock([]byte("GuMo")))

	var bndle, err = NewBundle(
		primary, []CanonicalBlock{prevNode, payload})

	if err != nil {
		t.Error(err)
	}

	for _, crcTest := range []CRCType{CRCNo, CRC16, CRC32, CRCNo} {
		bndle.SetCRCType(crcTest)

		if ty := bndle.PrimaryBlock.GetCRCType(); ty != crcTest {
			t.Errorf("Bundle's primary block has wrong CRCType, %v instead of %v",
				ty, crcTest)
		}

		buff := new(bytes.Buffer)
		if err := cboring.Marshal(&bndle, buff); err != nil {
			t.Fatal(err)
		}

		bndl2 := Bundle{}
		if err := cboring.Unmarshal(&bndl2, buff); err != nil {
			t.Fatal(err)
		}
	}
}

func TestBundleCbor(t *testing.T) {
	var epDest, _ = NewEndpointID("dtn:desty")
	var epSource, _ = NewEndpointID("dtn:gumo")
	var creationTs = NewCreationTimestamp(4200, 23)

	var primary = NewPrimaryBlock(
		StatusRequestDelivery,
		epDest, epSource, creationTs, 42000)

	var epPrev, _ = NewEndpointID("ipn:23.42")
	var prevNode = NewCanonicalBlock(23, 0, NewPreviousNodeBlock(epPrev))

	var payload = NewCanonicalBlock(
		1, DeleteBundle, NewPayloadBlock([]byte("GuMo meine Kernel")))

	bundle1, err := NewBundle(
		primary, []CanonicalBlock{prevNode, payload})
	if err != nil {
		t.Error(err)
	}

	bundle1.SetCRCType(CRC32)

	buff := new(bytes.Buffer)
	if err := cboring.Marshal(&bundle1, buff); err != nil {
		t.Fatal(err)
	}
	bundle1Cbor := buff.Bytes()

	bundle2 := Bundle{}
	if err := cboring.Unmarshal(&bundle2, buff); err != nil {
		t.Fatal(err)
	}

	buff.Reset()
	if err := cboring.Marshal(&bundle2, buff); err != nil {
		t.Fatal(err)
	}
	bundle2Cbor := buff.Bytes()

	if !bytes.Equal(bundle1Cbor, bundle2Cbor) {
		t.Fatalf("Cbor-Representations do not match:\n- %x\n- %x",
			bundle1Cbor, bundle2Cbor)
	}

	if !reflect.DeepEqual(bundle1, bundle2) {
		t.Fatalf("Bundles do not match:\n%v\n%v", bundle1, bundle2)
	}
}

// This function tests the serialization and deserialization of Bundles to CBOR
// et vice versa by comparing this implementation against uPCN's Python
// implementation. Thanks for this code!
//
// uPCN: https://upcn.eu/
// modified implementation dtn-bpbis-13: https://github.com/geistesk/upcn-bundle7
func TestBundleUpcn(t *testing.T) {
	// Serialized CBOR, generated by `python3 -m tools.bundle7`
	var upcnBytes = []byte{
		0x9f, 0x89, 0x07, 0x18, 0x84, 0x01, 0x82, 0x01, 0x63, 0x47, 0x53, 0x32,
		0x82, 0x01, 0x00, 0x82, 0x01, 0x00, 0x82, 0x00, 0x00, 0x1a, 0x00, 0x01,
		0x51, 0x80, 0x42, 0x45, 0x39, 0x86, 0x07, 0x02, 0x00, 0x02, 0x82, 0x01,
		0x63, 0x47, 0x53, 0x34, 0x44, 0x96, 0xcf, 0xec, 0xe0, 0x86, 0x09, 0x03,
		0x00, 0x02, 0x82, 0x18, 0x1e, 0x00, 0x44, 0x9f, 0x46, 0x74, 0xc7, 0x86,
		0x08, 0x04, 0x00, 0x02, 0x00, 0x44, 0xaf, 0x9b, 0xbf, 0x74, 0x86, 0x01,
		0x01, 0x00, 0x02, 0x4c, 0x48, 0x65, 0x6c, 0x6c, 0x6f, 0x20, 0x77, 0x6f,
		0x72, 0x6c, 0x64, 0x21, 0x44, 0xce, 0xa4, 0xb8, 0xbf, 0xff}

	bndl := Bundle{}
	if err := cboring.Unmarshal(&bndl, bytes.NewBuffer(upcnBytes)); err != nil {
		t.Fatal(err)
	}

	// Check PrimaryBlock fields
	pb := bndl.PrimaryBlock
	if ver := pb.Version; ver != dtnVersion {
		t.Errorf("Primary Block's version is not 7: %d", ver)
	}

	bcfExpected := MustNotFragmented |
		ContainsManifest
	if bcf := pb.BundleControlFlags; bcf != bcfExpected {
		t.Errorf("Primary Block's control flags mismatches: %x instead of %x",
			bcf, bcfExpected)
	}

	destExpected, _ := NewEndpointID("dtn:GS2")
	if dest := pb.Destination; dest != destExpected {
		t.Errorf("Primary Block's destination mismatches: %v instead of %v",
			dest, destExpected)
	}

	if src := pb.SourceNode; src != DtnNone() {
		t.Errorf("Primary Block's source node is not dtn:none: %v", src)
	}

	if rprtTo := pb.ReportTo; rprtTo != DtnNone() {
		t.Errorf("Primary Block's report to is not dtn:none: %v", rprtTo)
	}

	creaTsExpected := NewCreationTimestamp(DtnTimeEpoch, 0)
	if creaTs := pb.CreationTimestamp; creaTs != creaTsExpected {
		t.Errorf("Primary Block's creation timestamp mismatches: %v instead of %v",
			creaTs, creaTsExpected)
	}

	lifeExpected := uint64(24 * 60 * 60) // defined in PrimaryBlock's constructor
	if life := pb.Lifetime; life != lifeExpected {
		t.Errorf("Primary Block's lifetime mismatches: %v instead of %v",
			life, lifeExpected)
	}

	// Check Canonical Blocks
	var chkPayload, chkPreviousNode, chkHopCount, chkBundleAge bool

	for _, cb := range bndl.CanonicalBlocks {
		switch cb.BlockTypeCode() {
		case ExtBlockTypePayloadBlock:
			chkPayload = true

			payloadExpected := NewPayloadBlock([]byte("Hello world!"))
			payloadData := cb.Value.(*PayloadBlock)

			if !bytes.Equal(*payloadData, *payloadExpected) {
				t.Errorf("Payload Block's payload mismatches: %v instead of %v",
					payloadData, payloadExpected)
			}

		case ExtBlockTypePreviousNodeBlock:
			chkPreviousNode = true

			prevExpected := NewPreviousNodeBlock(MustNewEndpointID("dtn:GS4"))
			prevData := cb.Value.(*PreviousNodeBlock)

			if *prevData != *prevExpected {
				t.Errorf("Previous Node Block's EID mismatches: %v instead of %v",
					prevData, prevExpected)
			}

		case ExtBlockTypeHopCountBlock:
			chkHopCount = true

			hopExpected := NewHopCountBlock(30)
			hopData := cb.Value.(*HopCountBlock)

			if *hopData != *hopExpected {
				t.Errorf("Hop Count Block mismatches: %v instead of %v",
					hopData, hopExpected)
			}

		case ExtBlockTypeBundleAgeBlock:
			chkBundleAge = true

			ageExpected := NewBundleAgeBlock(0)
			ageData := cb.Value.(*BundleAgeBlock)

			if *ageData != *ageExpected {
				t.Errorf("Bundle Age Block's value mismatches: %d instead of %d",
					ageData, ageExpected)
			}

		default:
			t.Errorf("Unexpected Canonical Block: %v", cb)
		}
	}

	if !(chkPayload && chkPreviousNode && chkHopCount && chkBundleAge) {
		t.Error("Not all expected Canonical Blocks were found")
	}

	// Serialize CBOR again
	buff := new(bytes.Buffer)
	if err := bndl.MarshalCbor(buff); err != nil {
		t.Fatal(err)
	}
	recreatedBytes := buff.Bytes()

	if !bytes.Equal(upcnBytes, recreatedBytes) {
		t.Errorf("Serialization of uPCN's bundle differs: %v instead of %v",
			upcnBytes, recreatedBytes)
	}
}

func TestBundleExtensionBlock(t *testing.T) {
	var bndl, err = NewBundle(
		NewPrimaryBlock(
			MustNotFragmented,
			MustNewEndpointID("dtn:some"), DtnNone(),
			NewCreationTimestamp(DtnTimeEpoch, 0), 3600),
		[]CanonicalBlock{
			NewCanonicalBlock(2, 0, NewBundleAgeBlock(420)),
			NewCanonicalBlock(1, 0, NewPayloadBlock([]byte("hello world"))),
		})

	if err != nil {
		t.Error(err)
	}

	if cb, err := bndl.ExtensionBlock(ExtBlockTypePreviousNodeBlock); err == nil {
		t.Errorf("Bundle returned a non-existing Extension Block: %v", cb)
	}

	if _, err := bndl.ExtensionBlock(ExtBlockTypeBundleAgeBlock); err != nil {
		t.Errorf("Bundle did not returned the existing Bundle Age block: %v", err)
	}

	if _, err := bndl.ExtensionBlock(ExtBlockTypePayloadBlock); err != nil {
		t.Errorf("Bundle did not returned the existing Payload block: %v", err)
	}

	if _, err := bndl.PayloadBlock(); err != nil {
		t.Errorf("Bundle did not returned the existing Payload block: %v", err)
	}
}

// createNewBundle is used in the TestBundleCheckValid function and returns
// the Bundle with an ignored error. The error will be checked in this
// test case.
func createNewBundle(primary PrimaryBlock, canonicals []CanonicalBlock) Bundle {
	b, _ := NewBundle(primary, canonicals)

	return b
}

func TestBundleCheckValid(t *testing.T) {
	tests := []struct {
		b     Bundle
		valid bool
	}{
		// Administrative record
		{createNewBundle(
			NewPrimaryBlock(MustNotFragmented|AdministrativeRecordPayload,
				DtnNone(), DtnNone(), NewCreationTimestamp(42, 0), 3600),
			[]CanonicalBlock{
				NewCanonicalBlock(1, StatusReportBlock, NewPayloadBlock(nil))}),
			false},

		{createNewBundle(
			NewPrimaryBlock(MustNotFragmented|AdministrativeRecordPayload,
				DtnNone(), DtnNone(), NewCreationTimestamp(42, 0), 3600),
			[]CanonicalBlock{NewCanonicalBlock(1, 0, NewPayloadBlock(nil))}),
			true},

		// Block number (1) occures twice
		{createNewBundle(
			NewPrimaryBlock(MustNotFragmented|AdministrativeRecordPayload,
				DtnNone(), DtnNone(), NewCreationTimestamp(42, 0), 3600),
			[]CanonicalBlock{
				NewCanonicalBlock(1, 0, NewPayloadBlock(nil)),
				NewCanonicalBlock(1, 0, NewPayloadBlock(nil))}),
			false},

		// Two Hop Count blocks
		{createNewBundle(
			NewPrimaryBlock(MustNotFragmented|AdministrativeRecordPayload,
				DtnNone(), DtnNone(), NewCreationTimestamp(42, 0), 3600),
			[]CanonicalBlock{
				NewCanonicalBlock(23, 0, NewHopCountBlock(23)),
				NewCanonicalBlock(24, 0, NewHopCountBlock(23)),
				NewCanonicalBlock(1, 0, NewPayloadBlock(nil))}),
			false},

		// Creation Time = 0, no Bundle Age block
		{createNewBundle(
			NewPrimaryBlock(MustNotFragmented|AdministrativeRecordPayload,
				DtnNone(), DtnNone(), NewCreationTimestamp(0, 0), 3600),
			[]CanonicalBlock{
				NewCanonicalBlock(2, 0, NewBundleAgeBlock(42000)),
				NewCanonicalBlock(1, 0, NewPayloadBlock(nil))}),
			true},
		{createNewBundle(
			NewPrimaryBlock(MustNotFragmented|AdministrativeRecordPayload,
				DtnNone(), DtnNone(), NewCreationTimestamp(0, 0), 3600),
			[]CanonicalBlock{
				NewCanonicalBlock(1, 0, NewPayloadBlock(nil))}),
			false},
	}

	for _, test := range tests {
		if err := test.b.CheckValid(); (err == nil) != test.valid {
			t.Errorf("Block validation failed: %v resulted in %v",
				test.b, err)
		}
	}
}

func BenchmarkBundleSerializationCboring(b *testing.B) {
	var sizes = []int{0, 1024, 1048576, 10485760, 104857600}
	var crcs = []CRCType{CRCNo, CRC16, CRC32}

	for _, size := range sizes {
		for _, crc := range crcs {
			payload := make([]byte, size)

			rand.Seed(0)
			rand.Read(payload)

			primary := NewPrimaryBlock(
				0,
				MustNewEndpointID("dtn:dest"),
				MustNewEndpointID("dtn:src"),
				NewCreationTimestamp(DtnTimeEpoch, 0),
				60*60*1000000)

			canonicals := []CanonicalBlock{
				NewCanonicalBlock(2, 0, NewBundleAgeBlock(0)),
				NewCanonicalBlock(3, 0, NewPreviousNodeBlock(MustNewEndpointID("dtn:prev"))),
				NewCanonicalBlock(1, 0, NewPayloadBlock(payload)),
			}

			bndl := MustNewBundle(primary, canonicals)
			bndl.SetCRCType(crc)

			b.Run(fmt.Sprintf("%d-%v", size, crc), func(b *testing.B) {
				for i := 0; i < b.N; i++ {
					cboring.Marshal(&bndl, new(bytes.Buffer))
				}
			})
		}
	}
}

func BenchmarkBundleDeserializationCboring(b *testing.B) {
	var sizes = []int{0, 1024, 1048576, 10485760, 104857600}
	var crcs = []CRCType{CRCNo, CRC16, CRC32}

	for _, size := range sizes {
		for _, crc := range crcs {
			payload := make([]byte, size)

			rand.Seed(0)
			rand.Read(payload)

			primary := NewPrimaryBlock(
				0,
				MustNewEndpointID("dtn:dest"),
				MustNewEndpointID("dtn:src"),
				NewCreationTimestamp(DtnTimeEpoch, 0),
				60*60*1000000)

			canonicals := []CanonicalBlock{
				NewCanonicalBlock(2, 0, NewBundleAgeBlock(0)),
				NewCanonicalBlock(3, 0, NewPreviousNodeBlock(MustNewEndpointID("dtn:prev"))),
				NewCanonicalBlock(1, 0, NewPayloadBlock(payload)),
			}

			bndl := MustNewBundle(primary, canonicals)
			bndl.SetCRCType(crc)

			buff := new(bytes.Buffer)
			cboring.Marshal(&bndl, buff)
			data := buff.Bytes()

			b.Run(fmt.Sprintf("%d-%v", size, crc), func(b *testing.B) {
				for i := 0; i < b.N; i++ {
					tmpBuff := bytes.NewBuffer(data)
					tmpBndl := Bundle{}

					if err := cboring.Unmarshal(&tmpBndl, tmpBuff); err != nil {
						b.Fatal(err)
					}
				}
			})
		}
	}
}
